def can_transfer_data(n, q, s, sensor_queues, queue_sizes, downlink_windows):
    # Initialize the total data generated by sensors and the current queue sizes
    total_data = [0] * q
    for window in downlink_windows:
        d, sensor_data = window[0], window[1:]
        for i in range(s):
            total_data[i] += sensor_data[i]
        # Check if the data generated by sensors can be transferred in this window
        for i in range(q):
            if total_data[i] > queue_sizes[i]:
                return "impossible"
            queue_sizes[i] -= total_data[i]
        # Reset the sensor data after each window
        for i in range(s):
            total_data[i] = 0
    # Check if all queues are empty after the last downlink window
    for size in queue_sizes:
        if size != 0:
            return "impossible"
    return "possible"

# Read input
n, q, s = map(int, input().split())
sensor_queues = list(map(int, input().split()))
queue_sizes = list(map(int, input().split()))
downlink_windows = [list(map(int, input().split())) for _ in range(n)]

# Determine if data can be transferred
result = can_transfer_data(n, q, s, sensor_queues, queue_sizes, downlink_windows)
print(result)